// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use alloy::{
    consensus::{Header, TxEnvelope},
    eips::{BlockId, BlockNumberOrTag},
    primitives::{Bytes, FixedBytes},
    providers::{Provider, ProviderBuilder},
    rpc::types::{BlockTransactionsKind, Transaction},
};
use alloy_eips::eip2718::Encodable2718;
use alloy_rlp::Encodable;
use alloy_trie::{proof::ProofRetainer, HashBuilder, Nibbles};
use arrayvec::ArrayVec;
use methods::TX_INCLUSION_ELF;
use risc0_zkvm::{default_prover, ExecutorEnv};

/// Adjust the index of an item for rlp encoding.
/// Pulled from https://github.com/paradigmxyz/reth/blob/e427eb202715d12e09ba99df653e537cf5f5926a/crates/trie/common/src/root.rs#L11
pub const fn adjust_index_for_rlp(i: usize, len: usize) -> usize {
    if i > 0x7f {
        i
    } else if i == 0x7f || i + 1 == len {
        0
    } else {
        i + 1
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Alloy provider to query transactions for given block
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    let block = provider
        .get_block(
            BlockId::Number(BlockNumberOrTag::Latest),
            BlockTransactionsKind::Full,
        )
        .await?
        .expect("Failed to get latest block");

    let transactions: &[Transaction] = block
        .transactions
        .as_transactions()
        .expect("full block requested above");

    if transactions.is_empty() {
        panic!("No transactions in latest block");
    }

    let encoded_transactions: Vec<Vec<u8>> = transactions
        .into_iter()
        .map(|tx| {
            let tx_encodable: TxEnvelope = tx.clone().try_into().unwrap();

            let mut encoded = Vec::new();
            tx_encodable.encode_2718(&mut encoded);
            encoded
        })
        .collect();
    let txs_len = encoded_transactions.len();

    // Doesn't matter which transaction we pick for the proof, doing 0th for simplicity.
    let proof_index = adjust_index_for_rlp(0, txs_len);
    let encoded_index = alloy_rlp::encode_fixed_size(&proof_index);
    let proof_tx = encoded_transactions[proof_index].clone();
    let retainer = ProofRetainer::from_iter([Nibbles::unpack(&encoded_index)]);

    let mut hb = HashBuilder::default().with_proof_retainer(retainer);
    for i in 0..txs_len {
        let index = adjust_index_for_rlp(i, txs_len);

        let index_buffer = alloy_rlp::encode_fixed_size(&index);

        hb.add_leaf(Nibbles::unpack(&index_buffer), &encoded_transactions[index]);
    }

    // Sanity check to ensure the transactions merkle tree is correct.
    assert_eq!(hb.root(), block.header.transactions_root);

    let proof = hb.take_proof_nodes();
    let proof_nodes: Vec<_> = proof
        .matching_nodes_sorted(&Nibbles::unpack(&encoded_index))
        .iter()
        .map(|(_, node)| node.clone())
        .collect();

    // Note: other end of the serialization hack to serialize as RLP given alloy serde impl fails
    // with non-self describing serialization protocols.
    let header: Header = block.header.try_into().unwrap();
    let mut encoded_header = Vec::new();
    header.encode(&mut encoded_header);

    let inputs: (Vec<u8>, ArrayVec<u8, 9>, Vec<u8>, Vec<Bytes>) = (
        encoded_header,
        encoded_index,
        proof_tx,
        proof_nodes,
    );

    let mut input_bytes = postcard::to_allocvec(&inputs)?;
    let len: u32 = input_bytes.len().try_into()?;
    input_bytes.splice(0..0, len.to_le_bytes());

    // Generate proof of inclusion for the given block
    let env = ExecutorEnv::builder().write_slice(&input_bytes).build()?;
    let prover = default_prover();

    let prove_info = prover.prove(env, TX_INCLUSION_ELF)?;
    let receipt = prove_info.receipt;

    let (block_hash, transaction): (FixedBytes<32>, Vec<u8>) = receipt.journal.decode().unwrap();
    println!(
        "encoded transaction: {} proven included in {}",
        alloy::hex::encode(&transaction),
        block_hash
    );
    Ok(())
}
