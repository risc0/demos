// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use alloy::{
    consensus::TxEnvelope,
    eips::{BlockId, BlockNumberOrTag},
    providers::{Provider, ProviderBuilder},
    rpc::types::{BlockTransactionsKind, Transaction},
};
use alloy_eips::eip2718::Encodable2718;
use alloy_trie::{proof::ProofRetainer, HashBuilder, Nibbles};
use methods::{TX_INCLUSION_ELF, TX_INCLUSION_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};

/// Adjust the index of an item for rlp encoding.
/// Pulled from https://github.com/paradigmxyz/reth/blob/e427eb202715d12e09ba99df653e537cf5f5926a/crates/trie/common/src/root.rs#L11
pub const fn adjust_index_for_rlp(i: usize, len: usize) -> usize {
    if i > 0x7f {
        i
    } else if i == 0x7f || i + 1 == len {
        0
    } else {
        i + 1
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Alloy provider to query transactions for given block
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    let block = provider
        .get_block(
            BlockId::Number(BlockNumberOrTag::Latest),
            BlockTransactionsKind::Full,
        )
        .await?
        .expect("Failed to get latest block");

    let transactions: &[Transaction] = block
        .transactions
        .as_transactions()
        .expect("full block requested above");

    if transactions.is_empty() {
        panic!("No transactions in latest block");
    }

    let encoded_transactions: Vec<Vec<u8>> = transactions
        .into_iter()
        .map(|tx| {
            let tx_encodable: TxEnvelope = tx.clone().try_into().unwrap();

            let mut encoded = Vec::new();
            tx_encodable.encode_2718(&mut encoded);
            encoded
        })
        .collect();
    let txs_len = encoded_transactions.len();

    // Doesn't matter which transaction we pick for the proof, doing 0th for simplicity.
    let proof_index = adjust_index_for_rlp(0, txs_len);
    let encoded_index = Nibbles::unpack(alloy_rlp::encode_fixed_size(&proof_index));
    let proof_tx = encoded_transactions[proof_index].clone();
    let retainer = ProofRetainer::from_iter([encoded_index.clone()]);

    let mut hb = HashBuilder::default().with_proof_retainer(retainer);
    for i in 0..txs_len {
        let index = adjust_index_for_rlp(i, txs_len);

        let index_buffer = alloy_rlp::encode_fixed_size(&index);

        hb.add_leaf(Nibbles::unpack(&index_buffer), &encoded_transactions[index]);
    }

    // Sanity check to ensure the transactions merkle tree is correct.
    assert_eq!(hb.root(), block.header.transactions_root);

    let proof = hb.take_proof_nodes();
    alloy_trie::proof::verify_proof(
        hb.root(),
        encoded_index.clone(),
        Some(proof_tx),
        proof
            .matching_nodes_sorted(&encoded_index)
            .iter()
            .map(|(_, node)| node),
    )
    .unwrap();
    // // For example:
    // let env = ExecutorEnv::builder().build()?;

    // // Obtain the default prover.
    // let prover = default_prover();

    // // Proof information by proving the specified ELF binary.
    // // This struct contains the receipt along with statistics about execution of the guest
    // let prove_info = prover.prove(env, TX_INCLUSION_ELF)?;
    // let receipt = prove_info.receipt;

    // // The receipt was verified at the end of proving, but the below code is an
    // // example of how someone else could verify this receipt.
    // receipt.verify(TX_INCLUSION_ID)?;

    Ok(())
}
